#ifndef INC_ACCU_BASE_LIB_H_
#define INC_ACCU_BASE_LIB_H_

#include <LTC6811.h>

/* OverCurrent Thresholds */
#define CHARGE_CURR_THRESHOLD     8
#define DISCHARGE_CURR_THRESHOLD -170

/* Forward declaration of struct CAN_Handler to avoid errors */
struct         CAN_Handler;
typedef struct CAN_Handler  CAN_Handler;

/* CAN Variables */
extern CAN_HandleTypeDef hcan1;
extern CAN_HandleTypeDef hcan2;
extern CAN_RxHeaderTypeDef RxHeader1, RxHeader2;
extern CAN_TxHeaderTypeDef TxHeader1, TxHeader2;
extern uint8_t RxData1[8], RxData2[8], TxData1[8], TxData2[8];
extern uint32_t canMailbox;

/* BMS ErrorCode */
//extern BMS_Error_t bmsError;

/* BMS Error persists for more time */
extern uint32_t no_overvoltage_time;
extern uint32_t no_undervoltage_time;
extern uint32_t no_overvoltage_flag_time;
extern uint32_t no_undervoltage_flag_time;
extern uint32_t no_overcurrent_charge_time;
extern uint32_t no_overcurrent_discharge_time;
extern uint32_t no_overtemperature_time;
extern uint32_t no_undertemperature_time;
extern uint32_t no_isabelle_voltage_error_time;

/* Pre-Charge & AIR Situation EventBits */
typedef enum
{
	TS_OFF	   = 1<<0,
	AIRM_STATE = 1<<1,
	AIRP_STATE = 1<<2,

}TS_Off_EventBits_t;


typedef enum
{
	TS_INACTIVE	   = 1<<0,
	AIR_M_SUPP     = 1<<1,
	AIR_M_STATE    = 1<<2,
	AIR_P_SUPP	   = 1<<3,
	AIR_P_STATE	   = 1<<4,
	OVER_60V	   = 1<<5,
	PC_DONE 	   = 1<<6,
	PC_RELAY_ERROR = 1<<7,

}PreCharge_EventBits_t;

/* Error codes for TSAC on CANbus */



typedef enum
{
	SHORT_CIRCUIT       = 0,   //  0 Hz
	NORMAL                 ,   // 10 Hz
	IMD_UNDERVOLTAGE       ,   // 20 Hz
	SPEED_START            ,   // 30 Hz
	DEVICE_ERROR           ,   // 40 Hz
	FAULT_EARTH_CONNECTION ,   // 50 Hz
	UNDEFINED_FREQ         ,   // None of the above

}IMD_Condition_t;


/* Defined by the PWM Duty Cycle */
typedef enum
{
	INVALID_DC  = 0,  /* Duty Cycle received in any condition is out of range */
	DC_OK          ,  /* Duty cycle received in Normal and Undervoltage conditions is in range */
	SST_GOOD       ,  /* Good speed start meausrement (measurement taken at the beginning) */
	SST_BAD        ,  /* Bad speed start measurement */
	DEVICE_FAULT   ,  /* Error generated by PWM frequency of 40Hz or 50 Hz */

}IMD_Status_t ;



/* Accumulator Information */
typedef struct Accu_info
{
	enum
	{
		TSAC_OK 				  = 0,
		IMD_ERROR 				     ,
		AVI_STATUS_ERROR		  	 ,
		AIR_M_STUCK				     ,
		AIR_P_STUCK				     ,
		AIR_M_IMPLAUSIBILITY         ,
		AIR_P_IMPLAUSIBILITY         ,
		PC_RELAY_IMPLAUSIBILITY      ,
		PC_CIRCUIT_ERROR		     ,
		DCDC_OVERTEMP                ,

		ELCON_HW_FAILURE             ,
		ELCON_OVERTEMP_PROTECTION    ,
		ELCON_INPUT_ERROR            ,
		ELCON_REVERSE_POLARITY       ,
		ELCON_COMMUNICATION_ERROR    ,

	}state,
	 last_error;

	CAN_Handler* can_handler;     // PRIMARY CANBUS

	uint8_t tx_data[5];           // Data sent from the ACCU board to the Primary CANbus

	/* General Accumulator info */
	uint8_t ams_error      : 1;
	uint8_t imd_error		: 1;
	uint8_t AIR_P_Supp		: 1;
	uint8_t AIR_M_Supp		: 1;
	uint8_t AIR_P_State	: 1;
	uint8_t AIR_M_State	: 1;
	uint8_t over60V_dclink : 1;
	uint8_t vicor_overtemp  : 1;

	float    dc_dc_temp;
	uint8_t  HVroom_humidity;
	uint8_t  HVroom_temperature;

	float    precharge_voltage;   	  // Voltage level on pre-charge PTCs
	uint32_t precharge_time;	  	  // Theoretical calculation of Ï„ = 1/(RC)
	uint32_t AIR_M_closed_time;   	  // Moment the AIR- closed
	uint8_t  AIR_P_State_Int;	  	  // Desired state of AIR+
	uint8_t  precharge_actual_state;  // Actual state of the pre-charge relay

	uint8_t precharge_relay_error   : 1;
	uint8_t air_stuck				: 1;
	uint8_t ts_active				: 1;
	uint8_t precharge_done			: 1;
	uint8_t precharge_failed		: 1;

	/* GPIOs used on the PCB */
	GPIO_TypeDef *IMD_ok;
	uint16_t      IMD_ok_Pin;
	GPIO_TypeDef *PC_Indicator;
	uint16_t      PC_Indicator_Pin;
	GPIO_TypeDef *VS_OVER60V;
	uint16_t      VS_OVER60V_Pin;
	GPIO_TypeDef *AIR_M_Supp_3V;
	uint16_t      AIR_M_Supp_3V_pin;
	GPIO_TypeDef *AIR_P_Supp_3V;
	uint16_t      AIR_P_Supp_3V_pin;
	GPIO_TypeDef *AIR_M_State_3V;
	uint16_t      AIR_M_State_3V_pin;
	GPIO_TypeDef *AIR_P_State_3V;
	uint16_t      AIR_P_State_3V_pin;
	GPIO_TypeDef *AIR_P_Driver;
	uint16_t      AIR_P_Driver_pin;
	GPIO_TypeDef *LED;
	uint16_t      LED_pin;

	uint32_t tick_PC_Error;
	uint32_t tick_AIR_Stuck;

}Accu_info;



typedef struct Imd
{
	uint16_t rising_edge1;
	uint16_t falling_edge;
	uint16_t rising_edge2;
	uint16_t pulse_width;
	uint16_t period;

	uint16_t frequency;
	float    dutyCycle;

	bool rising_edge_detected;

	/* Modes of IMD */
	IMD_Condition_t condition;       /* Condition is determined from the frequency of the PWM */
	IMD_Status_t    status;          /* Status is determined from the Duty Cycle of the PWM */
	uint16_t        insulation_kOhm; /* Determines isolation from NORMAL and UNDERVOLTAGE conditions */

}Imd;



/* IsabellenHuette Struct */
typedef struct Ivt
{
	CAN_Handler* can_handler;

	uint8_t  rx_data[8];		// Data received from Isabelle

	/* IsabellenHuette measurements */
	float current;
	float voltage_vs;
	int16_t Wh_consumed;
	float Ah_consumed;
	float voltage_U2;    /* 2nd Isabelle voltage measurement - Not used */

	float discharge_current_threshold;
	float charge_current_threshold;

	/* IsabellenHuette timing */
	TickType_t IVT_I_Time;
	TickType_t IVT_I_Time_Previous;
	TickType_t IVT_U1_Time;
	TickType_t IVT_U1_Time_Previous;
	TickType_t IVT_U2_Time;
	TickType_t IVT_U2_Time_Previous;
	TickType_t IVT_U3_Time;
	TickType_t IVT_U3_Time_Previous;
	TickType_t IVT_AH_Time;
	TickType_t IVT_AH_Time_Previous;
	TickType_t IVT_WH_Time;
	TickType_t IVT_WH_Time_Previous;

}Ivt;



/* ELCON Charger CAN Interface */
typedef struct Elcon
{
	CAN_Handler* can_handler;
	bool 		 connected; 		// true if elcon is connected
	TickType_t   last_msg_received; // time when the last Elcon CAN message arrived, used to see if Elcon is alive

	uint8_t tx_data[5];     // Data sent to ELCON with CANbus (ID: 0x1806E5F4)
	uint8_t rx_data[5];		// Data received from ELCON with CANbus (ID: 0x18FF50E5)

	float output_voltage;	// Voltage and current that ELCON outputs
	float output_current;

	float target_current;	// Voltage and current to set the charger
	float target_voltage;

	bool  N_target_charge_state;	 // 0: Charging is ENABLED    1: Charging is DISABLED

	uint8_t spare_button_state;

	// Status flags
	uint8_t hw_fail            : 1;
	uint8_t charger_over_temp  : 1;
	uint8_t ac_input_error     : 1;
	uint8_t N_charge_state     : 1;  // 0: Charging ON    1: Charging OFF
	uint8_t can_error          : 1;

}Elcon;


void Accu_Struct_Init(Accu_info* accuInfo, CAN_Handler* can_handler,
	  	  	  	  	  GPIO_TypeDef *IMD_ok,
					  uint16_t      IMD_ok_Pin,
					  GPIO_TypeDef *PC_Indicator,
					  uint16_t      PC_Indicator_Pin,
	  	  	  	  	  GPIO_TypeDef *VS_OVER60,
					  uint16_t      VS_OVER60_Pin,
					  GPIO_TypeDef *AIR_M_Supp_3V,
					  uint16_t      AIR_M_Supp_3V_pin,
					  GPIO_TypeDef *AIR_P_Supp_3V,
					  uint16_t      AIR_P_Supp_3V_pin,
					  GPIO_TypeDef *AIR_M_State_3V,
					  uint16_t      AIR_M_State_3V_pin,
					  GPIO_TypeDef *AIR_P_State_3V,
					  uint16_t      AIR_P_State_3V_pin,
					  GPIO_TypeDef *AIR_P_Driver,
					  uint16_t      AIR_P_Driver_pin,
					  GPIO_TypeDef *LED,
					  uint16_t      LED_pin);

void IVT_Struct_Init(Ivt* ivt, CAN_Handler *can_handler);
void Elcon_Struct_Init(Elcon *elcon, CAN_Handler *can_handler);

/* Open SD from AMS Fault and check BMS Errors, concerning LTC6811 IC errors or other ACCU problems, like overCurrent */
void update_imd_status(Imd* imd);
void update_BMS_Errors(MCU *master, LTC6811 *slave_array, BMS_info *bmsInfo, Ivt *ivt, Accu_info* accuInfo);
void ams_fault(MCU* master, Accu_info* accuInfo);

/* Check TSAC Errors */
void update_TSAC_Errors(EventBits_t event_bits, Accu_info* accuInfo);

#endif /* INC_ACCU_BASE_LIB_H_ */
